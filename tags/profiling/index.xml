<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>profiling on Learn Everything</title>
    <link>https://shiver.github.io/tags/profiling/</link>
    <description>Recent content in profiling on Learn Everything</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2022 | Follow on &lt;a class=&#34;follow-item&#34; href=&#34;https://twitter.com/shivernz&#34; target=&#34;_blank&#34;&gt;Twitter&lt;/a&gt; | &lt;a class=&#34;follow-item&#34; href=&#34;https://github.com/shiver&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 25 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://shiver.github.io/tags/profiling/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Make your own quick, &#34;simple&#34; and portable heap allocation tracker in Rust</title>
      <link>https://shiver.github.io/post/tracking-heap-allocations-in-rust/</link>
      <pubDate>Thu, 25 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://shiver.github.io/post/tracking-heap-allocations-in-rust/</guid>
      <description>Introduction Besides altering your algorithms, another easy way to improve the performance of your code is by reducing heap allocations. Compared to the heap, stack allocations are significantly faster to both allocate and free, as they are usually done by simply updating a pointer, potentially in a single operation, and often by a dedicated CPU register.
The heap on the other hand is a complicated beast. There is a fair amount of bookkeeping involved when acquiring and potentially releasing memory for your application, and avoiding this overhead will usually net you some decent performance gains, especially if these are happening frequently in your code.</description>
    </item>
    
  </channel>
</rss>
